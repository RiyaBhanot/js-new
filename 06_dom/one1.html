<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>DOM Learning</title>
    <style>
        .bg-black {
            background-color: #212121;
            color: #fff;
        }
    </style>
</head>

<body class="bg-black">
    <div>
        <h1 id="title" class="heading ">DOM learning begin <span style="display: none;">hello</span></h1>
        <p>riya hi</p>
        <h2>vishal hi</h2>
        <h2>nrki hi</h2>
        <h2>payal di hi</h2>
        <h2>ayush hi</h2>
        <input type="password">
        <ul>
            <li class="list-item">one</li>
            <li class="list-item">two</li>
            <li class="list-item">three</li>
            <li class="list-item">four</li>
        </ul>
    </div>
</body>

</html>

<!-- Tried on console -->

<!-- document.getElementById('title')
<h1 id=​"title" class=​"heading ">​DOM learning begin​</h1>​

document.getElementById('title').id
'title'

document.getElementById('title').class
undefined

document.getElementById('title').className
'heading '

document.getElementById('title').getAttribute('id')
'title'

document.getElementById('title').getAttribute('className')
null

document.getElementById('title').getAttribute('class')
'heading '

document.getElementById('title').setAttribute('class','test')
undefined ---- but actually it overrides the class name by test
document.getElementById('title').setAttribute('class','test Heading')
undefined --- in this also it overrides the class name by test heading


--- here we have stored this in a title through which we csn easily access it.
const title = document.getElementById('title')
undefined
-- by only writing title, we can acess the document
title
<h1 id=​"title" class=​"heading ">​DOM learning begin​</h1>​

-- here we are changing background color by using the below method
title.style.backgroundColor = 'green'
'green'

--her we are applying other methods of styling which can manipulate the DOM
title
<h1 id=​"title" class=​"heading ">​DOM learning begin​</h1>​
title.style.backgroundColor = 'green'
'green'
title.style.padding = '20px'
'20px'
title.style.margin = '20px'
'20px'
title.style.border = 'solid'
'solid'
title.style.borderRadius = '20px'
'20px'
-----how to fetch a content in DOM
title.textContent  --- this will give all the content present
'DOM learning begin hello'  
title.innerText  --- this will give the content which is visible
'DOM learning begin'
title.innerHTML --- 
'DOM learning begin <span style="display: none;">hello</span>'

----------------*****************************----------------
The properties innerText, innerHTML, and textContent are used in DOM manipulation to access or modify the content of an element, 
but they serve different purposes and behave differently in various scenarios. 
Here's a comparison:
1. innerText
Represents the visible text of an element, excluding hidden elements.
Renders styles like display: none and respects CSS applied to the element.
Read-Only in some cases: If you retrieve innerText, it only fetches visible text, not the raw HTML structure.
Use Case:
When you want to retrieve or set the visible text content, considering the styles applied.

2. innerHTML
Represents the HTML content of an element, including child elements and their structure.
Allows you to get or set the entire HTML markup within an element.
Can parse and execute embedded HTML and scripts.
Use Case:
When you need to retrieve or set both text and HTML structure of an element.

3. textContent
Represents the raw text content of an element, including text from hidden elements.
Ignores HTML tags and does not parse HTML.
Slightly faster than innerText since it doesn't render styles.
Use Case:
When you want the pure text of an element without worrying about visibility or HTML tags.


------------selectors------------
document.querySelector('h2')
<h2>​vishal hi​</h2>​
 document.querySelector('#title')
<h1 id=​"title" class=​"heading ">​…​</h1>​
document.querySelector('.heading')
<h1 id=​"title" class=​"heading ">​…​</h1>​
 document.querySelector('input[type="password"]')
<input type=​"password">​
document.querySelector('ul')
<ul>​…​</ul>​<li>​…​</li>​<li>​…​</li>​<li>​…​</li>​</ul>​
const myul= document.querySelector('ul')
undefined
myul.querySelector('li')
<li>​…​</li>​::marker​"one"</li>​
const turngreen = myul.querySelector('li')
undefined
turngreen.style.backgroundColor = 'green'
'green'
turngreen.style.padding = '15px'
'15px'

we can also make changes to it such as-----
turngreen.innerText
'one'
turngreen.innerText = 'five'
'five'

------------------------------ Query selector all -------- nodelist
document.querySelectorAll('li')
NodeList(3) [li, li, li]0: li1: li2: lilength: 3[[Prototype]]: NodeList
const mylist = document.querySelectorAll('li')
undefined
mylist[0].style.color='green'
'green'
const mylist = document.querySelectorAll('h1')
undefined
const myh1 = document.querySelectorAll('h1')
undefined
myh1
NodeList [h1#title.heading]
myh1[0].style.color="green"
'green'


-----------query selector all ----- node list ---- using a for each loop
const mylist = document.querySelectorAll('li')
undefined
mylist.forEach(function (li) {
  li.style.backgroundColor = 'green'
})
  ---will change the color to green

-----------------how to apply loop on HTML collection as it doesnot support any looping thing so we have to convert it to 
array so that we can apply looping on it--------------

document.getElementsByClassName('list-item')
HTMLCollection(4) [li.list-item, li.list-item, li.list-item, li.list-item]0: li.list-item1: li.list-item2: li.list-item3: li.list-itemlength: 4[[Prototype]]: HTMLCollection

const tempclasslist = document.getElementsByClassName('list-item')

********converting into array*************
Array.from(tempclasslist)
(4) [li.list-item, li.list-item, li.list-item, li.list-item]0: li.list-item1: li.list-item2: li.list-item3: li.list-itemlength: 4[[Prototype]]: Array(0)at: ƒ at()concat: ƒ concat()constructor: ƒ Array()copyWithin: ƒ copyWithin()entries: ƒ entries()every: ƒ every()fill: ƒ fill()filter: ƒ filter()find: ƒ find()findIndex: ƒ findIndex()findLast: ƒ findLast()findLastIndex: ƒ findLastIndex()flat: ƒ flat()flatMap: ƒ flatMap()forEach: ƒ forEach()includes: ƒ includes()indexOf: ƒ indexOf()join: ƒ join()keys: ƒ keys()lastIndexOf: ƒ lastIndexOf()length: 0map: ƒ map()pop: ƒ pop()push: ƒ push()reduce: ƒ reduce()reduceRight: ƒ reduceRight()reverse: ƒ reverse()shift: ƒ shift()slice: ƒ slice()some: ƒ some()sort: ƒ sort()splice: ƒ splice()toLocaleString: ƒ toLocaleString()toReversed: ƒ toReversed()toSorted: ƒ toSorted()toSpliced: ƒ toSpliced()toString: ƒ toString()unshift: ƒ unshift()values: ƒ values()with: ƒ with()Symbol(Symbol.iterator): ƒ values()Symbol(Symbol.unscopables): {at: true, copyWithin: true, entries: true, fill: true, find: true, …}[[Prototype]]: Object

*********storing into a variable**********
const myconvertedArr = Array.from(tempclasslist)

myconvertedArr.forEach(function(li){
    li.style.color='orange'
})







-------------------------------------**************************************
Selectors in the DOM are methods or techniques used to access or target specific elements in the HTML structure for manipulation or inspection. 
They allow developers to interact with the DOM elements programmatically using JavaScript.

Types of Selectors in the DOM:
1. ID Selector
Targets an element by its unique id attribute.
Uses the getElementById() method.

2. Class Selector
Targets elements by their class attribute.
Uses the getElementsByClassName() method. Returns a live HTMLCollection (not an array)

3. Tag Name Selector
Targets elements by their tag name (e.g., div, p, span).
Uses the getElementsByTagName() method. Returns a live HTMLCollection

4. CSS Selector
Uses the querySelector() and querySelectorAll() methods.
Supports CSS-style selectors for flexible targeting.
querySelector()
Returns the first matching element.
querySelectorAll()
Returns all matching elements as a static NodeList.

5. Universal Selector
Targets all elements in the document using querySelectorAll('*').

6. Attribute Selector
Targets elements based on their attributes using CSS-style selectors.
const elements = document.querySelectorAll('[type="text"]');

7. Combination Selectors
Combine multiple selectors for complex queries.
const element = document.querySelector('div.myClass > p:first-child');

Real-Life Analogy:
Imagine a library with books arranged by genre, author, and title. Using DOM selectors is like choosing how you find a book:
ID Selector: Asking for a specific book by its barcode.
Class Selector: Looking for all books in the same genre.
Tag Name Selector: Finding all books in the "Science Fiction" section.
CSS Selector: Combining filters like "Science Fiction books by Asimov."



---------------- query selector and query selector all diff-----------------------
The main difference between querySelector and querySelectorAll lies in the number of elements they return and how they interact with the DOM.

1. querySelector
Returns the first matching element for the specified CSS selector.
If no element matches, it returns null.
Commonly used when you only need to work with a single element.
it returns the The first matching element

2. querySelectorAll
Returns all matching elements for the specified CSS selector as a static NodeList.
A NodeList is similar to an array but doesn't include all array methods (e.g., forEach works, but map does not).
If no elements match, it returns an empty NodeList.
Useful when you need to work with multiple elements.
it returns A static NodeList of all matching elements

Performance
querySelector is faster because it stops searching after finding the first match.
querySelectorAll searches the entire DOM to find all matching elements.


When to Use
querySelector: Use when you're sure you need only the first matching element, e.g., selecting the first navigation link.
querySelectorAll: Use when you need to manipulate or iterate over multiple elements, e.g., updating all items in a list.



----------------difference between HTML Collection and NodeList----------------------
Both HTMLCollection and NodeList are array-like collections of DOM elements, but they differ in their properties, behaviors, and use cases.

1. HTMLCollection
Represents a live collection of elements in the DOM.
Updates automatically if the DOM changes (e.g., elements are added or removed).
Contains only Element nodes (tags like <div>, <p>, etc.).
Does not support all array methods (like forEach, map, etc.).
Commonly returned by methods like:
document.getElementsByClassName()
document.getElementsByTagName()

2. NodeList
Represents a static or live collection, depending on how it is obtained:
Static NodeLists are returned by querySelectorAll(). They don’t update with DOM changes.
Live NodeLists are returned by childNodes.
Can contain any node type: elements, text nodes, comments, etc.
Partially supports array methods (e.g., forEach is supported, but map and filter are not).
Commonly returned by methods like:
document.querySelectorAll() (static)
Node.childNodes (live)

Which One to Use?
Use HTMLCollection when you need a live collection that reflects DOM changes.
Use NodeList when working with querySelectorAll or if you don’t need live updates.

 -->